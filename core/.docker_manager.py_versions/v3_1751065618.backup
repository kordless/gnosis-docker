"""
Docker management operations
"""

import asyncio
import json
import os
from typing import Dict, List, Optional, Any
from datetime import datetime

import docker
from docker.errors import DockerException, APIError, NotFound
from docker.models.containers import Container
from docker.models.images import Image

class DockerManager:
    """Handles all Docker operations"""
    
    def __init__(self):
        try:
            # Check if we're in a container with Docker socket mounted
            if os.path.exists('/var/run/docker.sock'):
                # Use the Unix socket (works in Linux containers)
                self.client = docker.DockerClient(base_url='unix://var/run/docker.sock')
            else:
                # Try to connect using environment detection
                # This will try various methods including:
                # - DOCKER_HOST environment variable
                # - Windows named pipe (//./pipe/docker_engine)
                # - TCP connection to localhost:2375
                self.client = docker.from_env()
            
            # Test connection
            self.client.ping()
            print(f"Successfully connected to Docker daemon")
        except DockerException as e:
            # If all else fails, try the Docker Desktop TCP endpoint
            try:
                # Docker Desktop on Windows often exposes TCP endpoint
                self.client = docker.DockerClient(base_url='tcp://localhost:2375')
                self.client.ping()
                print(f"Connected to Docker via TCP at localhost:2375")
            except:
                # Last resort: try the host.docker.internal address
                try:
                    self.client = docker.DockerClient(base_url='tcp://host.docker.internal:2375')
                    self.client.ping()
                    print(f"Connected to Docker via host.docker.internal:2375")
                except:
                    raise RuntimeError(f"Failed to connect to Docker: {e}")

    
    async def list_containers(self, all: bool = False, filters: Dict = None) -> List[Container]:
        """List containers"""
        try:
            loop = asyncio.get_event_loop()
            containers = await loop.run_in_executor(
                None, 
                lambda: self.client.containers.list(all=all, filters=filters)
            )
            return containers
        except Exception as e:
            raise DockerException(f"Failed to list containers: {e}")
    
    async def get_container(self, container_id: str) -> Optional[Container]:
        """Get a specific container"""
        try:
            loop = asyncio.get_event_loop()
            container = await loop.run_in_executor(
                None,
                self.client.containers.get,
                container_id
            )
            return container
        except NotFound:
            return None
        except Exception as e:
            raise DockerException(f"Failed to get container: {e}")
    
    async def start_container(self, container_id: str) -> bool:
        """Start a container"""
        try:
            container = await self.get_container(container_id)
            if not container:
                return False
            
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, container.start)
            return True
        except Exception as e:
            raise DockerException(f"Failed to start container: {e}")
    
    async def stop_container(self, container_id: str, timeout: int = 10) -> bool:
        """Stop a container"""
        try:
            container = await self.get_container(container_id)
            if not container:
                return False
            
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, container.stop, timeout)
            return True
        except Exception as e:
            raise DockerException(f"Failed to stop container: {e}")
    
    async def restart_container(self, container_id: str, timeout: int = 10) -> bool:
        """Restart a container"""
        try:
            container = await self.get_container(container_id)
            if not container:
                return False
            
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, container.restart, timeout)
            return True
        except Exception as e:
            raise DockerException(f"Failed to restart container: {e}")
    
    async def remove_container(self, container_id: str, force: bool = False, v: bool = False) -> bool:
        """Remove a container"""
        try:
            container = await self.get_container(container_id)
            if not container:
                return False
            
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, container.remove, force, v)
            return True
        except Exception as e:
            raise DockerException(f"Failed to remove container: {e}")
    
    async def get_container_logs(
        self, 
        container_id: str, 
        tail: int = 100,
        since: str = None,
        until: str = None,
        timestamps: bool = False
    ) -> Optional[str]:
        """Get container logs"""
        try:
            container = await self.get_container(container_id)
            if not container:
                return None
            
            loop = asyncio.get_event_loop()
            logs = await loop.run_in_executor(
                None,
                lambda: container.logs(
                    tail=tail,
                    since=since,
                    until=until,
                    timestamps=timestamps
                ).decode('utf-8')
            )
            return logs
        except Exception as e:
            raise DockerException(f"Failed to get logs: {e}")
    
    async def get_container_stats(self, container_id: str) -> Optional[Dict]:
        """Get container stats"""
        try:
            container = await self.get_container(container_id)
            if not container:
                return None
            
            loop = asyncio.get_event_loop()
            stats = await loop.run_in_executor(
                None,
                lambda: container.stats(stream=False)
            )
            
            # Process stats
            if stats:
                cpu_delta = stats['cpu_stats']['cpu_usage']['total_usage'] - \
                           stats['precpu_stats']['cpu_usage']['total_usage']
                system_delta = stats['cpu_stats']['system_cpu_usage'] - \
                              stats['precpu_stats']['system_cpu_usage']
                cpu_percent = (cpu_delta / system_delta) * 100.0 if system_delta > 0 else 0
                
                memory_usage = stats['memory_stats']['usage']
                memory_limit = stats['memory_stats']['limit']
                memory_percent = (memory_usage / memory_limit) * 100.0
                
                return {
                    'cpu_percent': round(cpu_percent, 2),
                    'memory_usage': memory_usage,
                    'memory_limit': memory_limit,
                    'memory_percent': round(memory_percent, 2),
                    'network': stats.get('networks', {}),
                    'block_io': stats.get('blkio_stats', {})
                }
            
            return None
        except Exception as e:
            raise DockerException(f"Failed to get stats: {e}")
    
    async def list_images(self) -> List[Image]:
        """List all images"""
        try:
            loop = asyncio.get_event_loop()
            images = await loop.run_in_executor(
                None,
                self.client.images.list
            )
            return images
        except Exception as e:
            raise DockerException(f"Failed to list images: {e}")
    
    async def pull_image(self, image_name: str, tag: str = 'latest') -> Dict:
        """Pull an image"""
        try:
            loop = asyncio.get_event_loop()
            image = await loop.run_in_executor(
                None,
                self.client.images.pull,
                image_name,
                tag
            )
            
            return {
                'id': image.id,
                'tags': image.tags,
                'size': image.attrs.get('Size', 0)
            }
        except Exception as e:
            raise DockerException(f"Failed to pull image: {e}")
    
    async def remove_image(self, image_id: str, force: bool = False) -> bool:
        """Remove an image"""
        try:
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(
                None,
                self.client.images.remove,
                image_id,
                force
            )
            return True
        except Exception as e:
            raise DockerException(f"Failed to remove image: {e}")
    
    async def build_image(self, path: str, tag: str, dockerfile: str = 'Dockerfile') -> Dict:
        """Build an image from a Dockerfile"""
        try:
            loop = asyncio.get_event_loop()
            
            # Build the image
            image, logs = await loop.run_in_executor(
                None,
                lambda: self.client.images.build(
                    path=path,
                    tag=tag,
                    dockerfile=dockerfile,
                    rm=True,
                    forcerm=True
                )
            )
            
            # Collect build logs
            build_logs = []
            for log in logs:
                if 'stream' in log:
                    build_logs.append(log['stream'].strip())
            
            return {
                'id': image.id,
                'tags': image.tags,
                'logs': build_logs
            }
        except Exception as e:
            raise DockerException(f"Failed to build image: {e}")
